#pragma once

#include <atomic>
#include <stdio.h>
#include <QObject>

// TODO: use C99 F.A.M instead

namespace wpn114
{

using byte_t = uint8_t;

// ================================================================================================
class rbuffer
// ================================================================================================
{

public:

    rbuffer()
    {

    }

    void
    allocate(size_t nbytes)
    {
        m_data = new byte_t[nbytes]();
        m_size = nbytes;
    }

    // --------------------------------------------------------------------------------------------
    bool
    can_read(size_t nbytes) const { return can_read() <= nbytes; }

    // --------------------------------------------------------------------------------------------
    size_t
    can_read() const
    // --------------------------------------------------------------------------------------------
    {
        size_t w = w_index, r = r_index;
        if (w > r) return w-r;
        else return (w-r+m_size) & m_size_mask;
    }

    // --------------------------------------------------------------------------------------------
    size_t
    can_write() const
    // --------------------------------------------------------------------------------------------
    {
        size_t w = w_index, r = r_index;

        if (w > r) return ((r-w+m_size) & m_size_mask)-1;
        else if (w < r) return (r-w)-1;
        else return m_size-1;
    }

    bool
    can_write(size_t nframes) const { return can_write() <= nframes; }

    // --------------------------------------------------------------------------------------------
    size_t
    read(byte_t* data, size_t nbytes = 0)
    // --------------------------------------------------------------------------------------------
    {





    }

    // --------------------------------------------------------------------------------------------
    size_t
    read_copy(byte_t* dest, size_t nbytes = 0)
    // --------------------------------------------------------------------------------------------
    {
        size_t free_cnt, cnt2, to_read, n1, n2;
        size_t r = r_index, w = w_index;

        if ((free_cnt = can_read()) == 0)
            return 0;

        to_read = nbytes > free_cnt ? free_cnt : nbytes;
        cnt2 = r+to_read;

        if (cnt2 > m_size) {
            n1 = m_size-r;
            n2 = cnt2 & m_size_mask;
        } else {
            n1 = to_read;
            n2 = 0;
        }

        memcpy(dest, &(m_data[r]), n1);
        r_index = (r+n1) & m_size_mask;

        if (n2) {
            memcpy(dest+n1, &(m_data[r]), n2);
            r_index = (r+n2) & m_size_mask;
        }

        return to_read;
    }

    // --------------------------------------------------------------------------------------------
    size_t
    peek(byte_t* data, size_t nframes = 0) const
    // --------------------------------------------------------------------------------------------
    {

    }

    // --------------------------------------------------------------------------------------------
    size_t
    reserve(void* dest, size_t nframes)
    // --------------------------------------------------------------------------------------------
    {

    }

    // --------------------------------------------------------------------------------------------
    size_t
    write(byte_t* source, size_t nframes)
    // --------------------------------------------------------------------------------------------
    {

    }

    // --------------------------------------------------------------------------------------------
    void
    read_fwd(size_t nframes)
    // --------------------------------------------------------------------------------------------
    {

    }

    // --------------------------------------------------------------------------------------------
    void
    write_fwd(size_t nframes)
    // --------------------------------------------------------------------------------------------
    {

    }

private:

    // --------------------------------------------------------------------------------------------
    std::atomic<size_t>
    w_index{0}, r_index{0};

    // --------------------------------------------------------------------------------------------
    size_t
    m_size{0}, m_size_mask{0};

    // --------------------------------------------------------------------------------------------
    byte_t*
    m_data = nullptr;

};



}
